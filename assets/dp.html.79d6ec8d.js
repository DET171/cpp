import{e as s}from"./app.475b67bf.js";import{_ as n}from"./plugin-vue_export-helper.21dcd24c.js";const a={},o=s(`<h1 id="dynamic-programming" tabindex="-1"><a class="header-anchor" href="#dynamic-programming" aria-hidden="true">#</a> Dynamic programming</h1><h2 id="dynamic-programming-explained" tabindex="-1"><a class="header-anchor" href="#dynamic-programming-explained" aria-hidden="true">#</a> Dynamic programming explained</h2><p>Dynamic progamming is a technique used to the vast majority of competitive programming, usually used to speed recursive or naive algorithms up. The simplest form of dynamic programming is to find fibonacci numbers. Dynamic programming can be applied when a problem can be solved using smaller versions of the same problem. Dynamic programming has 3 parts: A state, a transition and a base case. We shall demonstrate the use of a recursive method, followed by 2 types of dynamic programming, as well as the different parts. Naive recursive method:</p><div class="language-cpp ext-cpp line-numbers-mode"><pre class="shiki" style="background-color:#282c34;"><code><span class="line"><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sum</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">n</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (n </span><span style="color:#C678DD;">&lt;=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> n;</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sum</span><span style="color:#ABB2BF;">(n </span><span style="color:#C678DD;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sum</span><span style="color:#ABB2BF;">(n </span><span style="color:#C678DD;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>While this method works, it is far too slow and may check multiple numbers multiple times. At n = 5, sum(2) is recalculated 3 times.</p><h3 id="top-down-dp" tabindex="-1"><a class="header-anchor" href="#top-down-dp" aria-hidden="true">#</a> Top down DP</h3><p>Top down dynamic programming is a speedup of naive recursive functions, by preventing the need of recalculating the same function multiple times. This involves memoisation, which is the storing of previous answers. Top down Fibo algorithm:</p><div class="language-cpp ext-cpp line-numbers-mode"><pre class="shiki" style="background-color:#282c34;"><code><span class="line"><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[</span><span style="color:#D19A66;">100005</span><span style="color:#ABB2BF;">]</span><span style="color:#7F848E;font-style:italic;"> //All initially set to -1</span></span>
<span class="line"><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sum</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">n</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[n] </span><span style="color:#C678DD;">!=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">-</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[n];</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (n </span><span style="color:#C678DD;">&lt;=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">) {</span><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[n] </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> n; </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> n;}</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[n] </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sum</span><span style="color:#ABB2BF;">(n </span><span style="color:#C678DD;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sum</span><span style="color:#ABB2BF;">(n </span><span style="color:#C678DD;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[n];</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>The states are stored in memo[], and the transition is memo[n] = sum(n-1) + sum[n-2]. The base cases are when n &lt;= 1, memo[n] = 1; While this form of DP may be more intuitive sometimes, it usually takes up more memory.</p><h3 id="bottom-up-dp" tabindex="-1"><a class="header-anchor" href="#bottom-up-dp" aria-hidden="true">#</a> Bottom up DP</h3><p>Bottom up dynamic programming is where you calculate all states leading up to the state that you are searching for. Top down Fibo algorithm:</p><div class="language-cpp ext-cpp line-numbers-mode"><pre class="shiki" style="background-color:#282c34;"><code><span class="line"><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[n];</span></span>
<span class="line"><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[</span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">] </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">] </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">long</span><span style="color:#ABB2BF;"> i </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">; i </span><span style="color:#C678DD;">&lt;</span><span style="color:#ABB2BF;"> n; i</span><span style="color:#C678DD;">++</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[i] </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[i</span><span style="color:#C678DD;">-</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">] </span><span style="color:#C678DD;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">memo</span><span style="color:#ABB2BF;">[i</span><span style="color:#C678DD;">-</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The states are stored in memo[n], the base cases are memo[0] and memo[1], and the transition is memo[i] = memo[i-1] + memo[i-2].</p><h3 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion" aria-hidden="true">#</a> Conclusion</h3><p>The 2 forms of DP have their own advntages. While bottom-up DP is usually more intuitive, some question require the use of top-down DP. Regardless, both forms of DP help to speed up programs. In the future writeups, we will look at some common DP algorithms, as well as their applications.</p>`,15);function l(p,e){return o}var c=n(a,[["render",l]]);export{c as default};
