import{_ as k,r as l,o as g,c as f,d as s,a as t,b as n,w as a,e as o}from"./app.82486af2.js";const _={},v=t("h1",{id:"dynamic-programming",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#dynamic-programming","aria-hidden":"true"},"#"),n(" Dynamic programming")],-1),b=o(`<h2 id="dynamic-programming-explained" tabindex="-1"><a class="header-anchor" href="#dynamic-programming-explained" aria-hidden="true">#</a> Dynamic programming explained</h2><p>Dynamic programming is a technique used to the vast majority of competitive programming, usually used to speed recursive or naive algorithms up. It can be applied when a problem can be solved using smaller versions of the same problem.</p><p>Dynamic programming has 3 parts: a state, a transition and a base case.</p><p>The simplest example often used to explain dynamic programming is to find Fibonacci numbers. We shall demonstrate the use of a recursive method, followed by 2 types of dynamic programming, as well as the different parts.</p><p>Naive recursive method (TLEs):</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6),y={class:"katex"},x={class:"katex-mathml"},w=o('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span>',1),M={class:"katex"},N={class:"katex-mathml"},T=o('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">sum</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span>',1),q=o(`<h3 id="top-down-dp" tabindex="-1"><a class="header-anchor" href="#top-down-dp" aria-hidden="true">#</a> Top-down DP</h3><p>Top-down dynamic programming is a speedup of naive recursive functions, by preventing the need of recalculating the same function multiple times. This involves memoisation, which is the storing of previous solutions.</p><p>Top-down Fibonacci algorithm:</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">long</span> <span class="token keyword">long</span> memo<span class="token punctuation">[</span><span class="token number">100005</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// All initially set to -1</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="highlight-lines"><div class="highlight-line"> </div><br><div class="highlight-line"> </div><br><div class="highlight-line"> </div><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4),D={class:"katex"},O={class:"katex-mathml"},P=o('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span>',1),L=o(`<p>While this form of DP may be more intuitive sometimes, it usually takes up more memory.</p><h3 id="bottom-up-dp" tabindex="-1"><a class="header-anchor" href="#bottom-up-dp" aria-hidden="true">#</a> Bottom up DP</h3><p>Bottom-up dynamic programming is where you calculate all states leading up to the state that you are searching for.</p><p>Bottom-up Fibonacci algorithm:</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">long</span> <span class="token keyword">long</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
memo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> memo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> memo<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> memo<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The states are stored in \\text{memo}\\[n], the base cases are \\text{memo}\\[0] and \\text{memo}\\[1], and the transition is \\text{memo}\\[i] = \\text{memo}\\[i - 1] + \\text{memo}\\[i - 2].</p><h3 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion" aria-hidden="true">#</a> Conclusion</h3><p>The 2 forms of DP have their own advantages. While bottom-up DP is usually more intuitive, some questions require the use of top-down DP. Regardless, both forms of DP help to speed up programs.</p><h2 id="common-dp-algorithms" tabindex="-1"><a class="header-anchor" href="#common-dp-algorithms" aria-hidden="true">#</a> Common DP algorithms</h2><h3 id="prefix-suffix-sum" tabindex="-1"><a class="header-anchor" href="#prefix-suffix-sum" aria-hidden="true">#</a> Prefix/suffix sum</h3><h4 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction" aria-hidden="true">#</a> Introduction</h4>`,11),Q={class:"katex"},W={class:"katex-mathml"},B=o('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span>',1),C=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">long</span> <span class="token keyword">long</span> arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> i <span class="token operator">=</span> lb<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> ub<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  sum <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),F={class:"katex"},V={class:"katex-mathml"},j=o('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">NQ</span><span class="mclose">)</span></span></span>',1),I={class:"katex"},A={class:"katex-mathml"},E=t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.8778em","vertical-align":"-0.1944em"}}),t("span",{class:"mord mathnormal"},"Q")])],-1),S=o(`<h4 id="precomputation" tabindex="-1"><a class="header-anchor" href="#precomputation" aria-hidden="true">#</a> Precomputation</h4><p>Precomputation is the act of making calculations prior to the actual query. While some of this calculations may not be used, having a set of numbers to refer to is much faster than just recalculating each time, sort of like memoisation. For the prefix sum problem, notice than the sum of a range is equivalent to the sum of all numbers leading up to the end, minus the sum of all numbers leading up to the front of the range.</p><p>Hence, we can store the sums as so:</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">long</span> <span class="token keyword">long</span> arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> prefix<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">)</span>
    prefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    prefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> prefix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> sum <span class="token operator">=</span> prefix<span class="token punctuation">[</span>ub<span class="token punctuation">]</span> <span class="token operator">-</span> prefix<span class="token punctuation">[</span>lb <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4),H={class:"katex"},R={class:"katex-mathml"},U=o('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span>',1),z={class:"katex"},G={class:"katex-mathml"},J=o('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Q</span><span class="mclose">)</span></span></span>',1),K=t("h4",{id:"conclusion-1",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#conclusion-1","aria-hidden":"true"},"#"),n(" Conclusion")],-1),X=t("p",null,"Prefix sums is a good way of keeping track of range sums. While prefix sums are a good way of handling querys on range sums, it is unable to handle updates. In the chapter on trees, we will touch on this.",-1);function Y(Z,$){const d=l("Toc"),e=l("mi"),p=l("mo"),m=l("mn"),c=l("mrow"),i=l("annotation"),u=l("semantics"),r=l("math"),h=l("mtext");return g(),f("div",null,[v,s(d),b,t("p",null,[n("While this method works, it is far too slow and may check multiple numbers multiple times. At "),t("span",y,[t("span",x,[s(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(u,null,{default:a(()=>[s(c,null,{default:a(()=>[s(e,null,{default:a(()=>[n("n")]),_:1}),s(p,null,{default:a(()=>[n("=")]),_:1}),s(m,null,{default:a(()=>[n("5")]),_:1})]),_:1}),s(i,{encoding:"application/x-tex"},{default:a(()=>[n("n = 5")]),_:1})]),_:1})]),_:1})]),w]),n(", "),t("span",M,[t("span",N,[s(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(u,null,{default:a(()=>[s(c,null,{default:a(()=>[s(h,null,{default:a(()=>[n("sum")]),_:1}),s(p,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(e,null,{default:a(()=>[n("n")]),_:1}),s(p,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(i,{encoding:"application/x-tex"},{default:a(()=>[n("\\text{sum}(n)")]),_:1})]),_:1})]),_:1})]),T]),n(" is recalculated 3 times.")]),q,t("p",null,[n("The states are stored in \\text{memo}\\[], and the transition is \\text{memo}\\[n] = \\text{sum}\\[n - 1] + \\text{sum}\\[n - 2]. The base cases are when "),t("span",D,[t("span",O,[s(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(u,null,{default:a(()=>[s(c,null,{default:a(()=>[s(e,null,{default:a(()=>[n("n")]),_:1}),s(p,null,{default:a(()=>[n("≤")]),_:1}),s(m,null,{default:a(()=>[n("1")]),_:1})]),_:1}),s(i,{encoding:"application/x-tex"},{default:a(()=>[n("n \\leq 1")]),_:1})]),_:1})]),_:1})]),P]),n(", \\text{memo}\\[n] = n.")]),L,t("p",null,[n("The objective of this form of dynamic programming is to be able to find the sum of all elements over a given range in an array. Usually, the naive code would run in "),t("span",Q,[t("span",W,[s(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(u,null,{default:a(()=>[s(c,null,{default:a(()=>[s(e,{mathvariant:"script"},{default:a(()=>[n("O")]),_:1}),s(p,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(e,null,{default:a(()=>[n("N")]),_:1}),s(p,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(i,{encoding:"application/x-tex"},{default:a(()=>[n("\\mathcal{O}(N)")]),_:1})]),_:1})]),_:1})]),B]),n(" time for each query for a range sum:")]),C,t("p",null,[n("While this method may be fast to find the range sum for 1 query, if there are multiple queries, the algorithm would run in "),t("span",F,[t("span",V,[s(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(u,null,{default:a(()=>[s(c,null,{default:a(()=>[s(e,{mathvariant:"script"},{default:a(()=>[n("O")]),_:1}),s(p,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(e,null,{default:a(()=>[n("N")]),_:1}),s(e,null,{default:a(()=>[n("Q")]),_:1}),s(p,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(i,{encoding:"application/x-tex"},{default:a(()=>[n("\\mathcal{O}(NQ)")]),_:1})]),_:1})]),_:1})]),j]),n(" in the worst case, where "),t("span",I,[t("span",A,[s(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(u,null,{default:a(()=>[s(c,null,{default:a(()=>[s(e,null,{default:a(()=>[n("Q")]),_:1})]),_:1}),s(i,{encoding:"application/x-tex"},{default:a(()=>[n("Q")]),_:1})]),_:1})]),_:1})]),E]),n(" is the number of queries.")]),S,t("p",null,[n("While this method may seem too slow, it actually shortens down the time for each query to be "),t("span",H,[t("span",R,[s(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(u,null,{default:a(()=>[s(c,null,{default:a(()=>[s(e,{mathvariant:"script"},{default:a(()=>[n("O")]),_:1}),s(p,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(m,null,{default:a(()=>[n("1")]),_:1}),s(p,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(i,{encoding:"application/x-tex"},{default:a(()=>[n("\\mathcal{O}(1)")]),_:1})]),_:1})]),_:1})]),U]),n("! So, the time complexity of the program overall would be "),t("span",z,[t("span",G,[s(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(u,null,{default:a(()=>[s(c,null,{default:a(()=>[s(e,{mathvariant:"script"},{default:a(()=>[n("O")]),_:1}),s(p,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(e,null,{default:a(()=>[n("N")]),_:1}),s(p,null,{default:a(()=>[n("+")]),_:1}),s(e,null,{default:a(()=>[n("Q")]),_:1}),s(p,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(i,{encoding:"application/x-tex"},{default:a(()=>[n("\\mathcal{O}(N + Q)")]),_:1})]),_:1})]),_:1})]),J]),n(".")]),K,X])}const as=k(_,[["render",Y],["__file","dp.html.vue"]]);export{as as default};
